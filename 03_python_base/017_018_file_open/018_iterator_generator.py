print(" 迭代器 生成器 列表解释器")

"""
    迭代器 生成器 列表解释器
        
一、递归和迭代
    递归：在函数定义中使用函数自身的方法。（A调用A）
    迭代：利用变量的原值推算处变量的一个新值。（A不停调用B）
    
二、什么是迭代器协议
    1、迭代器协议：对象必须提供一个next方法，执行该方法要买返回一个迭代中的下一项，
           要么就引起一个 StopIteration 异常（只能往后走，不能往前走）
    2、可迭代对象：实现了迭代器协议的对象（如何实现：对象内部定义一个__iter__() 方法）
    3、协议是一种约定，可迭代对象实现了迭代器协议，python的内部工具（入for循环，sum,min，max函数等）
    使用迭代器协议访问对象。
    
    4、for循环调用可迭代对象
    for循环的本质：循环所有对象，全部使用迭代器协议。
    问题：for循环的本质是遵循迭代器协议去访问对象，那么for循环的对象肯定都是迭代器了!!
        那既然这样，for循环可以遍历（字符串、列表、元组、字典、集合、文件对象），那这些数据类型肯定都是迭代器对象。
        但是，定义的一个列表 l = [1, 2] 没有 l.next() 方法。这不矛盾了？？？
    其实：（字符串、列表、元组、字典、集合、文件对象）都是可迭代对象，只不过在for循环时，
        调用了他们内部的__iter__()方法，生成一个迭代器对象。
    然后，for循环调用迭代器对象的__next__方法取值，而且for循环会捕获 StopIteration 异常，以终止迭代。
    
四、为什么要用for循环
    序列类型字符串、列表、元组都有下标，他们可以通过下标进行访问，但是对于非序列类型如字典、集合、文件等无法通过下标访问。
    for循环基于迭代器协议提供了统一的可以遍历对象的方法，即在遍历之前，先调用对象的__iter__ 方法生成一个迭代器，
    然后使用迭代器协议去实现循环访问，这样所有的对象都可以通过for循环进行访问。
    
"""



"""
    
二、迭代器
    递归：在函数定义中使用函数自身的方法。（A调用A）
    迭代：利用变量的原值推算处变量的一个新值。（A不停调用B
1、概念
    迭代器，被用于迭代的对象。利用变量的原值推算处变量的一个新值。（A不停调用B）

2、为什么要有迭代器？什么是可迭代对象？什么是迭代器对象？
   为什么要有迭代器？
   对于序列类型：字符串、列表、元组，我们可以使用索引的方式迭代取出其包含的元素。但对于字典、集合、文件等类型是没有索引的，若还想取出其内部包含的元素，则必须找出一种不依赖于索引的迭代方式，这就是迭代器
   
   什么是可迭代对象？
   可迭代对象指的是内置有 __iter__ 方法的对象，即 obj.__iter__, 如下
"""
# "python".__iter__()
# (1,2,).__iter__()
# {1,2}.__iter__()
# [1,2].__iter__()
# {"a": 1}.__iter__()
# open("test.txt").__iter__()

"""
    什么是迭代器对象？
    可迭代对象执行 obj.__iter__()得到的结果就是迭代器对象；
    而迭代器对象指的是既内置有__iter__ 有内置有 __next__ 方法的对象。
"""
# #文件类型的迭代器对象
# open("test.txt").__iter__()
# open("test.txt").__next__()

"""
    注意：迭代器对象是可迭代对象；可迭代对象不一定是迭代器对象。
3、迭代器对象的使用
"""
# dic = {"a": 1, "b": 2}
# iter_dic = dic.__iter__()  # 得到字典的迭代器对象，该迭代器对象既有 _iter__ 又有 __next__
# print(iter_dic is iter_dic.__iter__())  # True ，迭代器调用 __iter__ 得到的对象还是本身
#
# print(iter_dic.__next__())  # a
# print(iter_dic.__next__())  # b
# # print(iter_dic.__next__())  # StopIteration 抛出异常

"""
4、for 循环调用迭代器
    for循环的工作原理：
    #1 执行in后面对象的dic.__iter__() 方法，得到一个迭代器对象 iter_dic
    #2 执行next(iter_dic), 将得到的值赋值给k,然后执行循环体代码
    #3 重复过程2，直到捕抓到异常 StopIteration,结束循环
"""
dic = {"a": 1, "b": 2}
for k in dic:
    print(dic[k])
# 结果：
#     1
#     2

"""
5、迭代器的优缺点
    优点：
        提供一种统一的、不依赖于索引的迭代方式
        惰性计算，节省内存
    缺点：
        无法获取长度（只有next完毕才知道到底几个值）
        一次性、只能往后走，不能回退
        
三、生成器
1、什么是生成器
    
"""