"""
__slots__
    1、__slots__ 是一个类变量，变量值可以是列表、元组或者可迭代对象，也可以是一个字符串（意味着所有实例只有一个数据属性）
    2、引子：使用点来访问属性本质就是在访问类或是对象的__dict__ 属性字典（类的字典是共享的，而每个实例是独立的）
    3、为何使用 __slots__ : 字典会占用大量内存，如果有一个属性很少的类，但是有很多实例，为了节省内存，可以使用 __slots__取代实例的 __dict__
        当你定义 __slots__ 后，__slots__ 就会为实例使用一种更为紧凑的内部标示。
        实例通过有一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这就跟元组或列表很类似。
        在 __slots__ 中列出的属性名在内部被映射到这个数组的指定小标上。使用 __slots__ 一个不好的地方就是不能给实例添加的属性，
        只能使用 __slots__ 中定义的那些属性名
    4、注意： 定义了__slots__ 后类不再支持一下普通类特征，比如多继承。
        大多数情况下，只有那些经常被使用到的用作数据结构的类上定义 __slots__ 比如在程序中需要创建某个类的几百万个实例对象。

    关于 __slots__ 的一个常见的误区是它可以作为一个封装工具来防止用户给实例添加新的属性。尽管使用 __slots__ 可以达到这样的目的，但是这并不是他的初衷。
    更多的事用来作为一个内存优化工具。

    使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
    除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。


"""


class Student:
    __slots__ = ["name", "age"]

    def __init__(self, name, age):
        self.name = name
        self.age = age


s = Student("xu", 100)
print(s.name)
print(s.age)
# s.gender = "男"  # AttributeError: 'Studen' object has no attribute 'gender'


# __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
class Student_1(Student):
    pass


s1 = Student_1("xu", 100)
s1.gender = "男"
print("s1 的属性： {}".format(s1.__dict__))  # s1 的属性： {'gender': '男'}


